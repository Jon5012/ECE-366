/**
 * This is an autogenerated netlist code from CircuitVerse. Verilog Code can be
 * tested on https://www.edaplayground.com/ using Icarus Verilog 0.9.7. This is an
 * experimental module and some manual changes make need to be done in order for
 * this to work.
 *
 * If you have any ideas/suggestions or bug fixes, raise an issue
 * on https://github.com/CircuitVerse/CircuitVerse/issues/new/choose
 */

/*
  Element Usage Report
    Input - 117 times
    XorGate - 2 times
    Output - 10 times
    AndGate - 13 times
    OrGate - 12 times
    SubCircuit - 9 times
    Ground - 2 times
    Splitter - 3 times
*/

/*
  Usage Instructions and Tips
    Labels - Ensure unique label names and avoid using verilog keywords
    Warnings - Connect all optional inputs to remove warnings
*/

// Sample Testbench Code - Uncomment to use

/*
module TestBench();

  reg a0, b0, a1, b1, a2, b2, a3, b3;

  wire s0, s1, s2, s3, c4;

  Main DUT0();

  \4bitripple  DUT1(s0, s1, s2, s3, c4, a0, b0, a1, b1, a2, b2, a3, b3);

  \32bitCLA  DUT2(a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3);

  initial begin
    a0 = 0;
    b0 = 0;
    a1 = 0;
    b1 = 0;
    a2 = 0;
    b2 = 0;
    a3 = 0;
    b3 = 0;

    #15
    $display("s0 = %b", s0);
    $display("s1 = %b", s1);
    $display("s2 = %b", s2);
    $display("s3 = %b", s3);
    $display("c4 = %b", c4);

    #10
    $display("s0 = %b", s0);
    $display("s1 = %b", s1);
    $display("s2 = %b", s2);
    $display("s3 = %b", s3);
    $display("c4 = %b", c4);

    $finish;

  end
endmodule

*/

module Main();
endmodule

module \1_bit_adder (S, Cout, A, B, Cin);
  output S,  Cout;
  input A, B, Cin;
  wire xor_1_out, and_1_out, or_0_out, and_0_out, xor_0_out;
  assign xor_1_out = xor_0_out ^ Cin;
  assign S = xor_1_out;
  assign and_1_out = xor_0_out & Cin;
  assign or_0_out = and_1_out | and_0_out;
  assign Cout = or_0_out;
  assign and_0_out = B & A;
  assign xor_0_out = A ^ B;
endmodule


module \4bitripple (s0, s1, s2, s3, c4, a0, b0, a1, b1, a2, b2, a3, b3);
  output s0,  s1,  s2,  s3,  c4;
  input a0, b0, a1, b1, a2, b2, a3, b3;
  wire \1_bit_adder_3_out_0 , \1_bit_adder_3_out_1 , \1_bit_adder_2_out_0 , \1_bit_adder_2_out_1 , \1_bit_adder_1_out_0 , \1_bit_adder_1_out_1 , \1_bit_adder_0_out_0 , \1_bit_adder_0_out_1 , Ground_0_out;
  \1_bit_adder  \1_bit_adder_3 (\1_bit_adder_3_out_0 , \1_bit_adder_3_out_1 , a3, b3, \1_bit_adder_2_out_1 );
  assign c4 = \1_bit_adder_3_out_1 ;
  assign s3 = \1_bit_adder_3_out_0 ;
  \1_bit_adder  \1_bit_adder_2 (\1_bit_adder_2_out_0 , \1_bit_adder_2_out_1 , a2, b2, \1_bit_adder_1_out_1 );
  assign s2 = \1_bit_adder_2_out_0 ;
  \1_bit_adder  \1_bit_adder_1 (\1_bit_adder_1_out_0 , \1_bit_adder_1_out_1 , a1, b1, \1_bit_adder_0_out_1 );
  assign s1 = \1_bit_adder_1_out_0 ;
  \1_bit_adder  \1_bit_adder_0 (\1_bit_adder_0_out_0 , \1_bit_adder_0_out_1 , a0, b0, Ground_0_out);
  assign s0 = \1_bit_adder_0_out_0 ;
  assign Ground_0_out = 1'b0;
endmodule

module Propagate(P, a3_a2_a1_a0, b3_b2_b1_b0);
  output P;
  input [3:0] a3_a2_a1_a0, b3_b2_b1_b0;
  wire or_3_out, and_2_out, or_2_out, and_1_out, or_1_out, and_0_out, or_0_out;
  
  assign or_3_out = b3_b2_b1_b0[3] | a3_a2_a1_a0[3];
  assign and_2_out = or_3_out & and_1_out;
  assign P = and_2_out;
  assign or_2_out = b3_b2_b1_b0[2] | a3_a2_a1_a0[2];
  assign and_1_out = or_2_out & and_0_out;
  assign or_1_out = b3_b2_b1_b0[1] | a3_a2_a1_a0[1];
  assign and_0_out = or_1_out & or_0_out;
  assign or_0_out = b3_b2_b1_b0[0] | a3_a2_a1_a0[0];
  
endmodule


module Generate(G, b3, a3, a3, b3, b2, a2, a2, b2, b1, a1, a1, b1, b0, a0);
  output G;
  input b3, a3, a3, b3, b2, a2, a2, b2, b1, a1, a1, b1, b0, a0;
  wire and_1_out, and_0_out, or_1_out, and_3_out, or_4_out, and_6_out, or_5_out, or_0_out, and_2_out, or_2_out, and_4_out, or_3_out, and_5_out;
  assign and_1_out = b0 & a0;
  assign and_0_out = or_0_out & and_1_out;
  assign or_1_out = and_2_out | and_0_out;
  assign and_3_out = or_2_out & or_1_out;
  assign or_4_out = and_4_out | and_3_out;
  assign and_6_out = or_3_out & or_4_out;
  assign or_5_out = and_5_out | and_6_out;
  assign G = or_5_out;
  assign or_0_out = b1 | a1;
  assign and_2_out = b1 & a1;
  assign or_2_out = b2 | a2;
  assign and_4_out = b2 & a2;
  assign or_3_out = b3 | a3;
  assign and_5_out = b3 & a3;
endmodule


module \4bitCLA (Cout, Cin, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a0, b0, a1, b1, b2, a2, b3, a3, a3, a3_a2_a1_a0);
  output Cout;
  input Cin, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a0, b0, a1, b1, b2, a2, b3, a3, a3;
  input [3:0] a3_a2_a1_a0;
  wire Generate_1_out, or_0_out, and_0_out;
  
  Generate Generate_1(Generate_1_out, b3, a3, a3, b3, b2, a2, a2, b2, b1, a1, a1, b1, b0, a0);
  assign or_0_out = Generate_1_out | and_0_out;
  assign Cout = or_0_out;
  assign and_0_out =  & Cin;
endmodule




module \32bitCLA (a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3);
  input a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3, a0, b0, a1, b1, b2, a2, b3, a3, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a3;
  wire \4bitCLA_2_out , \4bitCLA_3_out , \4bitCLA_0_out , \4bitCLA_1_out , Ground_0_out;
  \4bitCLA  \4bitCLA_2 (\4bitCLA_2_out , \4bitCLA_1_out , a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a0, b0, a1, b1, b2, a2, b3, a3, a3, );
  \4bitCLA  \4bitCLA_3 (\4bitCLA_3_out , \4bitCLA_2_out , , , , , , , , , , , , , , , , , , , , , , , );
  \4bitCLA  \4bitCLA_0 (\4bitCLA_0_out , Ground_0_out, a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a0, b0, a1, b1, b2, a2, b3, a3, a3, );
  \4bitCLA  \4bitCLA_1 (\4bitCLA_1_out , \4bitCLA_0_out , a2, a1, a0, a2, a3, a1, b0, b1, b1, b2, b2, b3, b3, a0, b0, a1, b1, b2, a2, b3, a3, a3, );
  assign Ground_0_out = 1'b0;
endmodule
